
## 목차
- [들어가며](#들어가며)
    - [문제가 된 문제](#문제가-된-문제)
- [잘못된 풀이](#잘못된-풀이)
    - [과정](#과정)

---


# 들어가며
## 문제가 된 문제
```C
#include <stdio.h>

int main(void) {

    int m = 100, p = 50;

    if (m%=100 != 1 && m++ > 0 ) {
         printf("m=%d, p=%d\n", m, p);
    }
    else {
        printf("m=%d, p=%d\n", ++m, ++p);
    }
}
```
> 문제: 위 코드의 실행 결과는 무엇일까요?

---


이 문제는 학교에서 C언어와 관련된 강의를 듣던 중 마주친 문제이다. 코드를 컴파일러에 넣고 실행시키니 결과는 `m=1, p=51`이었다. 혼란스러웠다. 나는 `m=2, p=51`일 것으로 예상했기 때문이다. <br>실행 결과 **p가 51이 나온다는 것**은 그 과정이 어떠하든 <U>`if`의 조건이 거짓</U>이 되어 `else`로 넘어가 `++p`<sup>[1](#footnote_1)</sup>가 연산되었다는 의미를 가진다. <span style="color:red">즉, 조건문 `m % = 100 != 1 && m++ > 0` 의 결과가 **거짓**이라는 것을 상기하면서 이 문제에 대한 풀이를 적어보겠다.</span>

---

# 잘못된 풀이
## 과정
내가 m=2일 것이라고 결론을 내린 과정은 이러하다.

**1. <mark>m%=100</mark> != 1 && m++ > 0**

`m%=100` 의 결과로 m은 0을 값으로 갖게 된다.<sup>[2](#footnote_2)</span> 

여기서 %= 연산을 풀어 써보면, m = m%100이 되는데 이것은 “m을 100으로 나눈 나머지를 다시 m에 저장하라”는 것과 같다. 여기서 m은 100이라는 값을 가진 정수 타입의 변수였다. 왜 과거형이냐하면, 변수라는 것은 말 그대로 변하는 것이기 때문에, 1)을 거치며 다시 0이라는 값을 가진 정수 타입의 변수가 되었기 때문이다.<sup>[3](#footnote_3)</span>


```
실행 전 m의 값: 100
실행 후 m의 값: 0
```

**2. <mark>m%=100 != 1</mark> && m++ > 0**

여기에서 0!=1의 결과로 이 부분은 참이 되어 1의 값을 갖게 된다.
0 NOT 1은 1이기 때문이다. <span style="color:#d2d2d2">~~말 그대로 0은 1이 아니므로 참인데, 컴퓨터는 참을 1로 처리한다.~~</span>
 아직 m값은 0이다.
또 조건식을 다시 생각해보면, 이제 이렇게 표현할 수 있다:
`참 AND m++ > 0`.

```
실행 전 m의 값: 0
실행 후 m의 값: 0
```





<!--주석--->
---
<a name="footnote_1">[1]</a> p의 값을 1 증가시킨다는 뜻이다.<br>
<a name="footnote_2">[2]</a> 변수가 값을 가지는 것은 엄밀히 말하면 그 값을 진짜로 가진 것이 아니라, 어딘가에 있는 값에 대한 참조를 하고 있다고 해석하는 것이 맞는데 이는 언어마다 다를 수 있다.<br>
<a name="footnote_3">[3]</a> 이 문제는 시시각각 코드가 진행됨에 따라 m이라는 변수의 값이 변하고 있기 때문에 혼란을 주는 유형이다.
