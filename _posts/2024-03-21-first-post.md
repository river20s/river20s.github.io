---
layout: post
title: "1주차 강의 노트"
category: [SCHOOL LECTURE, Security Threat Detection and Analysis]
---

# Ch 1. 기초 정적분석 기법
`2024-03-14(목)` | 보안위협탐지및분석

- [악성코드 분석이란?](#악성코드-분석이란)

   - [악성코드의 유형](#악성-코드의-유형)

    - [악성코드 분석의 일반 규칙](#악성코드-분석의-일반-규칙)
- [안티바이러스 스캐닝](#안티바이러스-스캐닝)
   
   ...




## 악성코드 분석이란?
- 악성코드 : 컴퓨터에 해를 끼치는 모든 코드
    - 바이러스, 트로이 목마, 웜 (...)
    - 화이트 개념 : 진단 코드 (목적에 따라 나쁘지 않은 경우도 있음)
- 악성코드 분석 목표
    - 네트워크 침입 대응에 필요한 정보를 알아내기 위함
    - 무슨 일이 정확히 발생했는지, 감염된 시스템과 파일이 무엇인지 확실히 인지하기
    - 의심스러운 특정 바이너리가 하는 행위와 피해 범위를 측정
    - 호스트 측면과 네트워크 측면으로 나뉘어 탐지
        - 호스트 측면: 악성코드 자체 특성이 아닌 시스템에 가한 행위 초점
        - 네트워크 측면: 네트워크 트래픽 모니터링을 통해 악성코드 탐지
- 악성코드 분석 기법
    - 기초 정적 분석: 실제 명령어를 보지 않고 **파일 자체**를 조사, 파일의 악성 여부 확인
    - 기초 동적 분석: 악성코드 실행 후 감염 흔적 등의 **시스템 행위** 관찰
    - 고급 정적 분석: **프로그램 명령어**가 하는 작업을 파악, **디스어셈블리**기능 요구 (기계어 → 어셈블리어)
    - 고급 동적 분석: **디버거**를 이용해 악성 실행 파일 **내부 상태**를 점검

    ### 악성 코드의 유형
    > 악성 코드를 분석 시 악성코드에 대한 선행 지식이 필요 → 행위 추측, 가설 확인

    #### 백도어 (`backdoor`)
    - 본래 유지보수 용도로 사용함
    - 공격자의 접근 허용
    - 컴퓨터에 자기 자신 설치
    - 공격자는 별도 인증 필요 없이 컴퓨터에 접속하여 명령어 실행이 가능함 

    #### 봇넷 (`botnet`)
    - 공격자가 시스템에 접근한다는 점에서 백도어와 유사
    - 동일한 봇넷에 감염된 모든 컴퓨터가 하나의 명령제어 서버(`C&C`, `Command-and-Control`)로부터 동일한 명령어를 수신하여 공격

    #### 다운로더 (`downloader`)
    - 다른 악성코드를 다운로드 하는 악성코드
    - 공격자는 접근 권한을 얻어 다운로더를 설치 / 또는 사용자가 직접 다운로더를 설치하게 유도
    - 다운로더 프로그램은 악성코드를 다운로드하고 설치

    #### 정보 유출 악성코드(`information-stealing malware`)
    - 피해자 컴퓨터에서 정보 수집하고 공격자에게 전송
    - 이메일, 온라인 뱅킹 접근 권한 얻고자 할 때 사용
    - 예) 스니퍼, 패스워드 해시 수집기, 키로거 

    #### 실행기(`launcher`)
    - 다른 악성 프로그램을 실행할 때 사용

    #### 루트킷(`rootkit`)
    - 다른 코드 내에서 자신의 존재를 숨기도록 설계한 악성코드
    - 본래 의미: 은폐와 은닉을 위한 컴퓨터 기술
    - 백도어와 같은 다른 악성코드를 함께 사용
        - 공격자의 원격 접속 허용
        - 코드 탐지 어려움
    
    #### 스케어 웨어(`scare ware`)
    - 감염된 사용자에게 겁을 줘서 구매를 유도
    > 악성코드에 감염 되었으니, 우리의 소프트웨어를 구매하여 치료하세요.
    - 실제 구매하면 `scare ware`만 삭제됨
    - 안티바이러스나 다른 보안프로그램으로 가장

    #### 스팸 전송 악성코드(`spam-sending malware`)
    - 사용자의 장비 감염시켜 스팸을 전송
    - 스팸 전송 서비스를 판매하여 악성코드 수익을 얻음

    #### 웜/바이러스(`worm`/`virus`)
    - 자기 자신을 복제해 추가로 컴퓨터 감염
    - 웜: 네트워크에서 연속적인 복사 기능 수행



## 악성코드 분석의 일반 규칙
- 세부사항에 집착하지 말자
- 작업할 때 여러가지 도구와 접근 방식이 있음을 기억하자
- '고양이와 쥐' 게임처럼 새로운 악성코드 분석 기법이 생기면 공격자에 의해 회피기법도 생김. **기법을 인지하고 이해하여 활용하자**

## 안티바이러스 스캐닝
-이미 알려진 여러 안티바이러스 프로그램을 통해 악성코드를 분석하는 것이 좋지만, 안티바이러스 도구들이 완벽하지만은 않다.

안티바이러스 도구는 의심 파일을 찾기 위해 **의심파일 시그니처**로 이루어진 데이터베이스, 행위 및 패턴 매칭 분석에 주로 의존한다.
```
1. 공격자가 코드를 쉽게 변조함으로써 시그니처 우회
2. 대중적이지 않은 바이러스는 시그니처에 미포함 되므로 탐지 불가능
3. 새롭고 독특한 악성코드로 휴리스틱 기법 우회
```
> 휴리스틱 기법: 휴리스틱(heuristics) 또는 발견법(發見法)이란 불충분한 시간이나 정보로 인하여 합리적인 판단을 할 수 없거나, 체계적이면서 합리적인 판단이 굳이 필요하지 않은 상황에서 <U>**사람들이 빠르게 사용할 수 있게 보다 용이**</U>하게 구성된 간편추론의 방법이다.

### 바이러스토탈
- 웹사이트 기반 여러 안티바이러스 스캐닝
- URL : https://www.virustotal.com/gui/home/upload


---

## 해시
- 파일의 무결성 점검하기 위해 사용
- 해시함수를 이용하여 임의의 길이를 갖는 임의의 데이터에 의해 고정된 길이의 데이터로 매핑된 값
### 파일의 진위
- 파일 전체를 안전한 장소에 보존해두고 나중에 비교하는 방법과 파일을 비교하는 대신 해시 값을 비교하는 방법이 있음
### 일방향 해시 함수(one-way hash function)
- 일방향 해시 함수는 입력과 출력이 각각 1개씩 있음
    - 입력: 메시지 `message`
    - 출력: 해시 값 `hash value`
#### 해시 함수의 입력
- 메시지는 인간이 읽을 수 있는 문서일 필요가 없음
- 메시지가 실제로 무엇을 나타내고 있는지 알 필요 없음
- 어떤 메시지든 단지 비트열로서만 취급함, 그 비트 열을 기초로 해시 값 계산
#### 해시 함수의 출력
- 해시 값의 길이는 메시지의 길이와 관계 없음
- 메시지가 몇 비트, 바이트, 기가 바이트라도 일방향 해시 함수는 고정된 길이의 해시 값을 출력함
- 예) SHA-1이라는 일방향 해시 함수의 해시 값은 항상 160bit
#### 일방향 해시 함수의 성질
- 임의의 길이 메시지로부터 고정 길이 해시 값 계산
- 고속으로 계산 가능
- 메시지가 다르면 해시 값도 다름
- 일방향성
#### 충돌 내성
- 충돌을 발견하기 어려운 성질
- 일방향 해시 함수는 충돌 내성이 필요함
#### 일방향 해시 함수의 일방향성
- 메시지로 부터 해시값을 계산하지만, 해시 값으로는 메시지를 계산해낼 수 없음
#### 용어
- 일방향 해시 함수는 아래와 같이도 불림
    - 메시지 다이제스트 함수
    - 메시지 요약 함수
    - 암호적 해시 함수
- 일방향 해시 함수의 입력 메시지를 프리-이미지 `pre-image`라고도 함 


# 실습코드
```
package project0314;
import java.io.*;
import java.io.UnsupportedEncodingException;
import java.security.*;

public class Hash_256 {

	public static void main(String[] args) throws NoSuchAlgorithmException, UnsupportedEncodingException{
		
		String message = "Baewha Hash";
		System.out.println(message);
		
		MessageDigest mdSHA245 = MessageDigest.getInstance("SHA-256");
		
		mdSHA245.update(message.getBytes("UTF-8"));
		
		byte[] result_HashValue = mdSHA245.digest();
		
		StringBuilder HashValueTo16 = new StringBuilder();
		
		for(int idx = 0; idx < result_HashValue.length; idx++) {
			String hexString = String.format("%02x", result_HashValue[idx]);
			HashValueTo16.append(hexString);
		}
		System.out.println(HashValueTo16);

	}

}

```

> `Baewha Hash` 부분에 다른 문자열을 넣을 때마다 동일한 길이의 중복되지 않는 다른 hash값이 출력됨을 알 수 있다.

